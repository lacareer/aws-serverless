 <!-- Use Cases -->

 NOTE THAT THE TEMPLATES, 1 AND 2, DID NOT WORK IN MY ACCOUNT BECAUSE IT DOES NOT ALLOW FOR CREATING GLUE JOBS. TRY IN AN ENTERPRISE ACCOUNT TO SEE IF THE TEMPLATES WORKS AS EXPECTED

 UNCOMMENT THE EVENTBRIDGE RULE TO ENSURE NEW OBJECTS ADDED TO THE BUCKETS ARE SCANNED

# Vulnerability Scanning
Discovering and reporting vulnerabilities and security issues by scanning documents is a common process. If you are a security partner, when a new customer is onboarded, there can be hundreds of thousands of files to scan. Similarly, if a security procedure changes, previously scanned files may need to be rescanned. Scanning a large number of files is a both time consuming and expensive process. In this module, you will learn to scale a vulnerability scanning application to quickly and efficiently handle hundreds of thousands of files.

<!-- Introduction -->
You are developing a security vulnerability scanning application that alerts you of sensitive information in plain text files. The application you have built executes a workflow that scans a single file for exposed social security numbers (SSNs) and, if one is detected, sends a message to a queue for further downstream processing.
You intended to scan files singly as they got uploaded to your S3 bucket, but, due to delays in development, you have accumulated a large backlog of unscanned, potentially vulnerable files in S3.

<!-- What you do in the module -->
In this module, you will scale your security vulnerability scanning application using Step Functions Distributed Map to quickly address this backlog by processing multiple files concurrently.

# What you will accomplish

- Create a state machine using Distributed Map to process multiple files concurrently.

- Modify items before they are passed on to child executions using ItemSelector and batch input.

- Refactor code for batch processing.

- Monitor executions, events, map runs, and executions.

<!-- Reviewing the Workflow using template-1.yaml-->
- Open the Step Functions console .

- Select the state machine containing “VulnerabilityScanningStateMachine” in its name.

- Click Edit to review the design in Workflow Studio.

- Select the Lambda state titled “Scan”.

- Under API Parameters, click View function to review the Code.

- Return to Workflow Studio.

- Select the Choice state.

- Under Choice Rules, click the edit icons to expand the rule logic.

# The state machine orchestrates a Lambda function which scans a single file and, if an exposed SSN is detected, sends an SQS message with the location of the SSN and its serial number (the last four numbers).

<!-- Executing the Workflow -->
- Open the S3 console .

- Click the name of the bucket containing "vulnerabilitydatabucket".

- Copy both the full name of the bucket and the name of a file in that bucket.

- Return to Workflow Studio.

- Click Execute.

- Enter the following input, replacing [bucket name] and [file name] with the names you copied:

    {
        "detail": {
            "bucket": {
                "name": "[bucket name]"
            },
            "object": {
                "key": "[file name]"
            }
        }
    }

- Click Start execution then wait a moment for the execution to succeed.

# Your successful graph will vary depending on the file name you copied. Only executions that process a file with an exposed SSN will send a message to the queue.

<!-- Scaling the Workflow with Distributed Map -->

# Update the SF manually using the instructions below or move to the next section to deploy template-2.yaml

- Click Edit state machine.

- Select the Code tab.

- Overwrite the SF JSON definition with the following:

{
  "StartAt": "Map",
  "States": {
    "Map": {
      "Type": "Map",
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "DISTRIBUTED",
          "ExecutionType": "STANDARD"
        },
        "StartAt": "Scan",
        "States": {
          "Scan": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "OutputPath": "$.Payload",
            "Parameters": {
              "Payload.$": "$",
              "FunctionName": ""
            },
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.AWSLambdaException",
                  "Lambda.SdkClientException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 2,
                "MaxAttempts": 6,
                "BackoffRate": 2
              }
            ],
            "Next": "Choice"
          },
          "Choice": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.ssns",
                "IsPresent": true,
                "Next": "Queue"
              }
            ],
            "Default": "Pass"
          },
          "Queue": {
            "Type": "Task",
            "Resource": "arn:aws:states:::sqs:sendMessage",
            "Parameters": {
              "MessageBody.$": "$",
              "QueueUrl": ""
            },
            "End": true
          },
          "Pass": {
            "Type": "Pass",
            "End": true
          }
        }
      },
      "End": true,
      "Label": "Map",
      "MaxConcurrency": 1000,
      "ItemReader": {
        "Resource": "arn:aws:states:::s3:listObjectsV2",
        "Parameters": {
          "Bucket.$": "$.bucket",
          "Prefix.$": "$.prefix"
        }
      }
    }
  }
}


- Select the Design tab.

- Select the Lambda state titled “Scan”.

- Under API Parameters, click on the Enter function name dropdown then select the name containing “VulnerabilityScanning”.

- Select the SQS state titled "Queue".

- Under API Parameters, click on the Enter queue URL dropdown then select the URL containing “VulnerabilitiesQueue”.

- Select the Map state.

- Under Item source, expand Additional configuration.

- Select Limit number of items then enter 1000 under Max items.

- Select Modify Items with ItemSelector then enter the following JSON:
ItemSelector (formerly "Parameters") lets you modify items before they are passed on to the child workflow execution. Select which values to use from the item source, and add static values if needed


    {
        "detail": {
            "bucket": {
                "name.$": "$.bucket"
            },
            "object": {
                "key.$": "$$.Map.Item.Value.Key"
            }
        }
    }

- Under Child execution type, choose Express.

- Select the Code tab again to review the JSON definition.

- If the changes to the JSON definition look accurate, click Save.

<!--  Workflow using template-2.yaml-->

Delete  stack created with template-1.yaml and deploy template-2.yaml

<!-- Executing the Map Workflow -->
- Click Execute.

- Enter the following input, replacing [bucket name] with the bucket name you copied:

    {
        "bucket": "[bucket name]",
        "prefix": ""
    }

- Click Start execution.

- Under Events, click Map Run.

- Click a given child execution.

- After a successful execution, select the Execution input and output tab.

- Return to the parent execution view.

- Open the SQS console .

- Select the queue containing "VulnerabilitiesQueue" in its name.

- Click Send and receive messages.

- Click Poll for messages.

- Click a given message to view the Body.

- Click Done.

- Click the queue name.

- Under the queue name, click Purge.

- Enter purge then click Purge.
